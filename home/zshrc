export PATH=$HOME/bin:/usr/local/bin:$PATH
export TERM=xterm-256color

export EDITOR="nvim"
export VISUAL="nvim"

export LESS='-F -R -X'

alias reload="exec zsh"

# Load local OpenAI key if present
if [ -f "$HOME/.config/.open_api_key" ]; then
  source "$HOME/.config/.open_api_key"
fi

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time oh-my-zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/robbyrussell/oh-my-zsh/wiki/Themes

ZSH_DISABLE_COMPFIX="true"
MODE_INDICATOR="%B%F{red}<N>%f%b"
VI_MODE_SET_CURSOR=true
VI_MODE_RESET_PROMPT_ON_MODE_CHANGE=true
# Path to your oh-my-zsh installation. Export early so we can probe plugin dirs.
export ZSH="$HOME/.oh-my-zsh"

# Prevent fpath duplicates
typeset -U path fpath

# Which plugins would you like to load?
# We'll only enable plugins that actually exist to avoid oh-my-zsh warnings.
# Desired plugins list:
desired_plugins=(
  git 
  zsh-syntax-highlighting
  zsh-autosuggestions
  vi-mode
  zsh-autopair
)

# Build plugins array from available plugin directories
plugins=()
for p in "${desired_plugins[@]}"; do
  if [ -d "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/$p" ] || [ -d "$ZSH/plugins/$p" ]; then
    plugins+=($p)
  fi
done

# Enable simple completion caching to speed up completion
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path "$HOME/.zsh/cache"
mkdir -p "$HOME/.zsh/cache"

# colors, a lot of colors!
function clicolors() {
    i=1
    for color in {000..255}; do;
        c=$c"$FG[$color]$colorâœ”$reset_color  ";
        if [ `expr $i % 8` -eq 0 ]; then
            c=$c"\n"
        fi
        i=`expr $i + 1`
    done;
    echo $c | sed 's/%//g' | sed 's/{//g' | sed 's/}//g' | sed '$s/..$//';
    c=''
}

ZSH_THEME="green-tinted"
ZSH_DISABLE_COMPFIX=true
OMZ_ASYNC_THRESHOLD=0
# Disable async prompt updates
DISABLE_ASYNC_PROMPT=true

OMZ_ASYNC_DISABLE=true
VI_MODE_SET_CURSOR=true
VI_MODE_RESET_PROMPT_ON_MODE_CHANGE=true

# Standard plugin installation is handled by oh-my-zsh; source it now.
source $ZSH/oh-my-zsh.sh

autoload -Uz compinit
compinit

# Better completion behavior
setopt AUTO_MENU
setopt COMPLETE_IN_WORD
setopt ALWAYS_TO_END
autoload -Uz bracketed-paste-magic
zle -N bracketed-paste bracketed-paste-magic

unset -f _omz_async_request

# Ensure RPROMPT is set
RPROMPT='$(vi_mode_prompt_info)'

git_prompt_info() {
    ref=$(command git symbolic-ref HEAD 2> /dev/null) || \
    ref=$(command git rev-parse --short HEAD 2> /dev/null) || return 0
    echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}$ZSH_THEME_GIT_PROMPT_SUFFIX"
}

export ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=118'

# Ensure ZSH_HIGHLIGHT_STYLES is an associative array before assigning
if ! typeset -p ZSH_HIGHLIGHT_STYLES >/dev/null 2>&1; then
  typeset -A ZSH_HIGHLIGHT_STYLES
fi
ZSH_HIGHLIGHT_STYLES[comment]='fg=244'

# Vi-mode cursor configuration
# Blinking block in insert mode
VI_MODE_CURSOR_INSERT=1

# Steady block in normal mode  
VI_MODE_CURSOR_NORMAL=2

# Or use these custom functions for more control
function zle-keymap-select {
  if [[ ${KEYMAP} == vicmd ]] || [[ $1 = 'block' ]]; then
    # Normal mode - steady block
    echo -ne '\e[2 q'
  elif [[ ${KEYMAP} == main ]] || [[ ${KEYMAP} == viins ]] || [[ $1 = 'beam' ]]; then
    # Insert mode - blinking block
    echo -ne '\e[1 q'
  fi
}
zle -N zle-keymap-select

# Start with blinking block (insert mode)
echo -ne '\e[1 q'

# Also reset cursor on new prompt
function zle-line-init {
  echo -ne '\e[1 q'
}
zle -N zle-line-init
bindkey -M viins '^G' vi-cmd-mode
# clicolors

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='mvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch x86_64"

# Set personal aliases, overriding those provided by oh-my-zsh libs,
# plugins, and themes. Aliases can be placed here, though oh-my-zsh
# users are encouraged to define aliases within the ZSH_CUSTOM folder.
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"
if ! command -v eza &> /dev/null; then
  echo "[!!]  eza not found defaulting to ls. Install with: brew install eza"

  alias ll="ls -lahG"
  alias ls="ls -aG"
  alias li="ls -la | grep ^l | cut -c 53-"
else
  export EZA_COLORS="reset:bu=0:di=36:ln=36:ex=1;32"
  alias ls="eza"
  #alias ll="eza -la --total-size --no-user"
  #alias tree="eza -aG --tree -L 2 --color=always | less -RF"
  unalias ll 2>/dev/null 
  function ll() {
    command eza -l --no-user --color=always "$@" | less
  }

  function llh() {
    command eza -la --no-user --color=always "$@" | less
  }

  # Size-calculating version
  function lls() {
    eza -la --no-user --total-size --color=always "$@" | less
  }

  # Show user and group info for when you really need it
  function llu() {
    command eza -lag --color=always "$@" | less -RFXS
  }

  function tree() {
    eza -aG --tree -L 2 --color=always "$@" | less -RFSX
  } 
  alias lt="tree"
fi


alias site='docker exec -it $(docker ps -qf ancestor=site-server) site'
alias sitesh='docker exec -it $(docker ps -qf ancestor=site-server) bash'

alias dc="docker-compose"

if [ -n "$INSIDE_EMACS" ]; then
    if [[ "$INSIDE_EMACS" = nil ]]; then
        print -P "ZSH inside emacs environment..."
        chpwd() { print -P "\033AnSiTc %d" }
        print -P "\033AnSiTu %n"
        print -P "\033AnSiTc %d"
    fi
fi

vterm_printf() {
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ]); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}



ENABLE_CORRECTION="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
HIST_STAMPS="yyyy-mm-dd"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Enables directory tracking when running in emacs

if [[ "$INSIDE_EMACS" = 'vterm' ]]; then
    vterm_prompt_end() {
        vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
    }
    setopt PROMPT_SUBST
    PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
fi



# Helpers: update and compile zsh plugins for faster startup
ZSH_PLUGINS_DIR="${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins"
_zsh_plugins_list=(zsh-syntax-highlighting zsh-autosuggestions)

update-zsh-plugins() {
  echo "Updating zsh plugins in: $ZSH_PLUGINS_DIR"
  for p in "${_zsh_plugins_list[@]}"; do
    if [ -d "$ZSH_PLUGINS_DIR/$p/.git" ]; then
      printf "\nUpdating %s...\n" "$p"
      git -C "$ZSH_PLUGINS_DIR/$p" pull --ff-only --recurse-submodules || git -C "$ZSH_PLUGINS_DIR/$p" fetch --all
    elif [ -d "$ZSH_PLUGINS_DIR/$p" ]; then
      printf "%s exists but is not a git repo (skipping)\n" "$p"
    else
      printf "%s is missing\n" "$p"
    fi
done
}

compile-zsh-plugins() {
  if ! command -v zcompile >/dev/null 2>&1; then
    echo "zcompile not available; skipping compilation"
    return 0
  fi
  echo "Compiling plugin scripts to .zwc where possible..."
  for p in "${_zsh_plugins_list[@]}"; do
    plugdir="$ZSH_PLUGINS_DIR/$p"
    if [ -d "$plugdir" ]; then
      # compile any .zsh/.sh/plugin script files we find
      for f in "$plugdir"/*.zsh "$plugdir"/*.sh "$plugdir"/*.plugin.zsh; do
        [ -f "$f" ] || continue
        printf "Compiling %s\n" "$f"
        zcompile -q "$f" 2>/dev/null || true
      done
    fi
done
}

export HOMEBREW_NO_ENV_HINTS=1

# Combined helper
zsh-plugins-setup() {
  update-zsh-plugins
  compile-zsh-plugins
}

# Provide a convenient alias to run the helpers quickly
alias zpsetup='zsh-plugins-setup'

# Git prompt configuration - [branch] with bright branch name
ZSH_THEME_GIT_PROMPT_PREFIX="[%{$fg_bold[cyan]%}"
ZSH_THEME_GIT_PROMPT_SUFFIX="%{$reset_color%}]"
ZSH_THEME_GIT_PROMPT_DIRTY=""
ZSH_THEME_GIT_PROMPT_CLEAN=""
  

PROMPT='%{$fg[green]%}%~ %{$fg[cyan]%}$(git_prompt_info)%{$reset_color%}
$ '

# Add the vi-mode indicator on the right
RPROMPT='$(vi_mode_prompt_info)'

export PATH="$HOME/.local/bin:$PATH"

# Mise (version manager)
eval "$(mise activate zsh)"

alias kotlin-app='gradle init --type kotlin-application --dsl kotlin'

# After everything else loads, override the hook
function zle-keymap-select {
  VI_KEYMAP=$KEYMAP
  
  # Keep cursor behavior
  if [[ ${KEYMAP} == vicmd ]] || [[ $1 = 'block' ]]; then
    echo -ne '\e[2 q'
  elif [[ ${KEYMAP} == main ]] || [[ ${KEYMAP} == viins ]] || [[ $1 = 'beam' ]]; then
    echo -ne '\e[1 q'
  fi
  
  zle reset-prompt
}
zle -N zle-keymap-select

function zle-line-init {
  VI_KEYMAP=main
  zle reset-prompt
}
zle -N zle-line-init

# Set cursor to be a blinking block
echo -ne '\e[1 q'

# pnpm
export PNPM_HOME="/Users/jmdb/Library/pnpm"
case ":$PATH:" in
  *":$PNPM_HOME:"*) ;;
  *) export PATH="$PNPM_HOME:$PATH" ;;
esac
# pnpm end
